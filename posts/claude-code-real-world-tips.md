# 클로드 코드로 월 $200 날리기 전에 꼭 알아야 할 것들

"이번 달 클로드 요금이 200달러가 나왔는데요..."

세미나에 참석한 개발자가 자신의 경험을 공유하며 말했습니다. 많은 사람들이 공감의 웃음을 지었죠. 우리 모두 비슷한 경험이 있으니까요.

AI 코딩 도구를 쓰면서 가장 먼저 마주치는 현실은 **돈**입니다. 마법 같은 생산성 뒤에는 현실적인 비용이 따라옵니다.

오늘은 실제로 클로드 코드를 현업에서 3개월 이상 사용하며 시행착오를 겪은 개발자의 **진짜 노하우**를 공유합니다. 토큰을 아끼면서도 생산성은 높이는 방법, 그리고 당장 내일부터 쓸 수 있는 실전 팁들입니다.

---

## 💸 첫 번째 현실: 토큰은 돈이다

### 순진했던 시작

8월 어느 날, "클로드 코드 한번 써볼까?" 하는 가벼운 마음으로 시작했습니다.

**월정액은 아깝다고 생각해서 API 종량제를 선택했습니다.**

- 1일차: "오 좋네? 생산성 개쩐다!"
- 2일차: "완전 편하네, 이거 왜 진작 안 썼지?"
- 3일차: "...청구서 확인 중..."

**결과: $50**

하루 2시간씩 3일만 썼는데 50달러가 나왔습니다.

### 비유: 무제한 샐러드바의 함정

클로드 코드를 종량제로 쓰는 건 **무제한 샐러드바에서 접시 무게로 계산하는 것**과 같습니다.

```
"아 이거 공짜니까 막 담아도 되겠지?"
→ 계산대: "38,000원입니다"
→ "네...?"
```

AI도 마찬가지입니다. 질문 한 번, 파일 읽기 한 번이 전부 토큰이고, 토큰은 곧 돈입니다.

### 플랜 전쟁의 역사

그래서 플랜을 바꿔가며 실험했습니다:

**1단계: Pro 플랜 ($20/월)**
- "이 정도면 충분하겠지?"
- → 일주일 만에 한도 소진
- "...더 비싼 거 써야겠다"

**2단계: Max 5x 플랜 ($100/월)**
- Pro 대비 토큰 5배!
- 당시 최강 모델 Opus 4.1 사용
- 아웃풋 토큰 비용: 1M당 $75 (말도 안 되는 가격)
- → 이것도 금방 소진

**3단계: Teams 플랜 ($200/월)**
- "더 이상은... 없다..."
- 드디어 안정적으로 사용 가능

**4단계: 구원의 Sonnet 4.5 등장**
- Opus보다 성능 좋음
- 비용은 1M당 $15로 **5분의 1**
- "이제 좀 살 만하네"

### 그런데 새로운 적이 나타났다

**Weekly Limit (주간 사용량 제한)**

기존의 5시간 세션 제한과는 **완전히 다른 개념**입니다.

**5시간 세션 제한:**
- 내가 얼마나 많이 대화했는가 (토큰)
- 내가 통제 가능

**Weekly Limit:**
- AI가 얼마나 많이 '생각'했는가 (컴퓨팅 시간)
- 내가 통제 불가능

비유하자면:
- 세션 제한 = 식당 메뉴 선택 횟수 제한
- Weekly Limit = 주방에서 요리하는 시간 제한

**결론: 돈 쓰지 않으려면 전략이 필요합니다.**

---

## 📊 사용량 추적: 당신의 토큰을 지켜라

### /usage 명령어

클로드 코드에서 `/usage` 입력하면 현재 사용량을 볼 수 있습니다:

```
Current Session: 45K / 200K tokens (22%)
Weekly Limit: 3.2 hours / 15 hours
```

**해석:**
- 현재 세션에서 22% 사용 중
- 이번 주 전체 컴퓨팅 시간의 21% 소비

### Pro 플랜 통계

**5시간 세션 = 최대 225번 질문**

평균적으로:
- 1분당 0.75번 질문
- 1시간당 45번 질문

**현실:**
- 복잡한 작업: 10~20번만 해도 한도 소진
- 간단한 작업: 100번 넘게 가능

### /context 명령어

`/context` 입력하면 현재 컨텍스트 윈도우 상태를 볼 수 있습니다:

```
Total: 200K tokens
MCP Tools: 45K (22%)
Free Space: 155K (78%)
```

**교훈:** MCP를 많이 연결하면 **실제 작업 공간이 줄어듭니다.**

---

## 🎯 토큰 절약 4대 전략

실전에서 검증된 네 가지 핵심 전략입니다.

### 전략 1: 토큰 최적화 - Serena MCP

**문제:**
```
개발자: "이 함수 어디서 쓰이는지 찾아줘"
클로드: *전체 프로젝트 5000개 파일 읽기*
→ 50K 토큰 소비
```

**해결책: Serena MCP**

Serena는 **코드를 미리 인덱싱**해둡니다.

비유하자면:
- 기존: 도서관에서 책을 하나하나 다 펼쳐보기
- Serena: 도서 검색 시스템으로 필요한 책만 찾기

**작동 원리:**
1. LSP로 코드베이스 분석
2. 함수, 클래스, 변수를 심볼로 인덱싱
3. 검색 시 필요한 부분만 정확히 찾아줌

**효과:**
```
기존: getUserProfile 찾으려고 100개 파일 읽음 (30K 토큰)
Serena: 정확히 2개 파일만 읽음 (2K 토큰)
→ 93% 절약!
```

**공식 통계: 최대 70% 토큰 절약**

### 전략 2: 일관된 작업 흐름 - Task Master AI

**문제:**
```
개발자: "로그인 기능 만들어줘"
클로드: "어떤 로그인이요? 어디에 넣을까요? 뭘 먼저 할까요?"
→ 15번의 왔다갔다 질문
→ 20K 토큰 낭비
```

**해결책: Task Master AI**

비유: **요리 레시피북**

나쁜 방식:
```
"저녁 해줘"
→ "뭐 먹을래? 어떻게 조리? 재료는? 간은?"
→ 30분 동안 대화
```

좋은 방식:
```
📖 레시피:
1. 고기 200g 준비
2. 양념장 만들기
3. 굽기 15분
4. 플레이팅
```

**Task Master 작동 방식:**

1. PRD (제품 요구사항) 문서를 txt로 작성
2. Task Master가 읽어서 세부 태스크로 분할
3. AI는 한 번에 하나의 태스크만 수행
4. 자동으로 다음 태스크로 이동

**효과:**
- 명확한 작업 범위
- 불필요한 질문 제거
- 일관된 품질

### 전략 3: Sequential Thinking - 단계별 사고

**문제:**

AI가 한 번에 모든 걸 처리하려다가 실수합니다.

```
"로그인 페이지 만들어줘"
→ AI가 한 번에 생각
→ useState를 useContext로 착각
→ 전체 다시 작업
```

**해결책: Sequential Thinking**

Anthropic 공식 MCP입니다.

**작동 방식:**

AI가 생각을 단계별로 기록하도록 강제합니다.

```
Step 1: 요구사항 분석
→ 로그인 폼 필요
→ 이메일/비밀번호 입력
→ 제출 버튼

Step 2: 상태 관리 선택
→ 간단한 폼이므로 useState 적합
→ 전역 상태 불필요

Step 3: 구현
→ 폼 컴포넌트 작성
→ 유효성 검사 추가
```

**비유: 수학 문제 풀이**

나쁜 학생:
```
문제 보자마자 바로 답 적기
→ 틀림
→ "어디서 틀렸지?"
```

좋은 학생:
```
1. 문제 이해
2. 풀이 계획
3. 단계별 계산
4. 검증
→ 정확함
```

### 전략 4: 환각(Hallucination) 제거

**문제:**

AI가 최신 정보를 모릅니다.

```
"Next.js App Router로 해줘"
→ *Pages Router 코드 생성*
→ "왜 안 돼지?"
```

**해결책 A: Context7**

유명 라이브러리의 공식 문서를 마크다운으로 정리해둔 서비스입니다.

```
AI: "Next.js 어떻게 써요?"
Context7: *최신 공식 문서 제공*
AI: "아 App Router는 이렇게 쓰는구나"
```

**해결책 B: Perplexity MCP**

웹 검색으로 최신 정보를 가져옵니다.

```
"React 19 새 기능 뭐야?"
→ Perplexity가 웹 검색
→ 최신 블로그, 공식 문서 종합
→ 정확한 답변
```

**비유: 선생님의 참고서**

옛날 선생님:
```
1990년 교과서로 2024년 수업
→ "컴퓨터는 집채만큼 큽니다"
```

Context7 선생님:
```
2024년 최신 교과서
→ "AI가 코딩을 도와줍니다"
```

---

## 🛠️ 실전 MCP 활용법

### 사람처럼 작업하게 만들기

**문제:**

AI는 화면을 볼 수 없습니다.

```
개발자: "이 버튼 디자인대로 만들어줘"
AI: *상상으로 만듦*
→ 전혀 다름
```

**해결책: Figma MCP + Chrome MCP**

#### Figma MCP

디자인을 직접 읽습니다.

```
1. Figma에서 디자인 링크 복사
2. AI에게 전달
3. AI가 디자인 읽어서 구현
```

**비유: 요리사와 레시피**

나쁜 요리사:
```
"파스타 만들어"
→ 상상으로 만듦
→ "이건 라면인데요?"
```

좋은 요리사:
```
*레시피 사진 보면서*
"면은 이렇게, 소스는 저렇게..."
→ 완벽한 파스타
```

#### Chrome MCP

브라우저 화면을 스크린샷으로 확인합니다.

```
1. 코드 작성
2. 브라우저에 렌더링
3. AI가 스크린샷 찍어서 확인
4. "버튼이 오른쪽으로 3px 밀렸네, 고치자"
5. 자동 수정
```

**Playwright vs Chrome DevTools**

| 항목 | Playwright | Chrome DevTools |
|------|-----------|-----------------|
| 토큰 사용 | 많음 (4배) | 적음 (1배) |
| 기능 | 풍부 | 기본적 |
| 속도 | 느림 | 빠름 |

**결론: 웬만하면 Chrome DevTools 쓰세요!**

### Database 연동

**Postgres MCP**

실제 DB에 연결해서 작업합니다.

```
AI: "users 테이블 구조 알려줘"
→ *실제 DB 조회*
→ 정확한 스키마 파악
→ 맞춤 쿼리 작성
```

**⚠️ 주의사항:**

반드시 **읽기 전용** 권한으로 연결하세요!

```
❌ DELETE, UPDATE, DROP 권한 주지 마세요
✅ SELECT만 허용
```

---

## 💡 MCP의 함정: 많다고 좋은 게 아니다

### 컨텍스트 윈도우 전쟁

```
/context 결과:

Total: 200K tokens
MCP Tools: 90K (45%) ← 너무 많음!
Free Space: 110K (55%)
```

**문제:**

MCP를 10개 연결하면:
- 실제 작업 공간이 절반으로 줄어듦
- 세션이 금방 끝남
- 토큰 낭비

**해결책:**

**선택적 활성화**

```
작업별 MCP 조합:

프론트엔드 작업:
✅ Figma MCP
✅ Chrome MCP
✅ Context7
❌ Postgres MCP
❌ Task Master

백엔드 작업:
✅ Postgres MCP
✅ Task Master
✅ Sequential Thinking
❌ Figma MCP
❌ Chrome MCP
```

**비유: 도구 상자**

나쁜 목수:
```
모든 도구를 작업대에 펼쳐놓음
→ 작업 공간 없음
→ 불편함
```

좋은 목수:
```
지금 필요한 도구 3개만
→ 작업 공간 확보
→ 효율적
```

---

## 🤖 서브 에이전트: 일꾼을 고용하자

### 메인 vs 서브 에이전트

**메인 컨텍스트:**
- 당신과 대화하는 AI
- 전체 작업 지휘
- 한정된 컨텍스트 윈도우

**서브 에이전트:**
- 메인이 시키는 특정 작업 수행
- **독립된** 컨텍스트 윈도우
- 메인 컨텍스트를 소모하지 않음!

**비유: 프로젝트 매니저와 팀원**

```
PM (메인):
"A야, 디자인 구현해"
"B야, 테스트 작성해"

A (서브 에이전트):
*독립된 공간에서 작업*
→ PM의 머릿속 용량 안 써도 됨

B (서브 에이전트):
*독립된 공간에서 작업*
→ PM의 머릿속 용량 안 써도 됨
```

### 실전 워크플로우

```
.claude/claude.md 파일 작성:

Development Workflow:
1. Dev Agent: 코드 구현
2. Reviewer Agent: 코드 리뷰
3. Dev Agent: 수정 (필요시)
4. Reviewer Agent: 최종 승인
```

**작동 방식:**

1. 메인: "로그인 기능 만들어"
2. Dev Agent 호출 (독립 실행)
   - 코드 작성
   - 테스트 작성
   - 완료 보고
3. Reviewer Agent 호출 (독립 실행)
   - 코드 검증
   - 문제점 발견
   - 개선안 제시
4. 문제 있으면 Dev Agent 재호출
5. 승인될 때까지 반복

**장점:**
- 메인 컨텍스트는 깨끗하게 유지
- 더 긴 세션 가능
- 작업 품질 향상

### BMat Metathings 플러그인

최근 Claude 2.0에서 **플러그인 마켓플레이스**가 생겼습니다.

`/plugin install bmat-metathings` 하면 설치됩니다.

**포함된 기능:**
- 브레인스토밍 도우미
- 시장 조사 에이전트
- 아이디어 검증 에이전트
- 재무 계획 에이전트
- 애자일 스프린트 매니저

**사용 예시:**

```
/brainstorm "SaaS 아이디어"
→ 30개 아이디어 + 각각 검증
→ 시장 규모 분석
→ 수익 모델 제안
```

단순히 코딩만이 아니라 **비즈니스 전체**를 도와줍니다.

---

## 🎬 실전 데모: 진짜로 이렇게 씁니다

### 준비물

1. **Figma 설정**
   - Actions > Preferences
   - "Enable Desktop MCP Server" 체크
   - Dev 모드에서 디자인 링크 복사

2. **터미널 환경**
   - Ghostty (크로스 플랫폼 터미널)
   - tmux (세션 관리)
   - Neovim (에디터)

**왜 이 조합?**
- Ghostty: Windows/Mac/Linux 모두 지원
- tmux: 세션이 끊기지 않음
- Neovim: 빠르고 효율적

### 실제 작업 흐름

**1단계: 워크플로우 정의**

`.claude/claude.md` 작성:
```markdown
# Development Workflow

Use two agents:

1. **Frontend Dev Agent**
   - Read Figma design
   - Implement component
   - Write tests

2. **Reviewer Agent**
   - Verify implementation
   - Check design match
   - Approve or request changes

Continue until approved.
```

**2단계: 작업 시작**

```
나: "Figma 링크 읽고 구독 플랜 UI 만들어줘"

Claude: *Q&A 레이아웃 표시*

질문 1: 구현 범위?
답변: "간단한 UI"

질문 2: 컴포넌트 구조?
답변: "단일 컴포넌트"

질문 3: 상태 관리?
답변: "useState"

질문 4: 스타일링?
답변: "Figma 그대로"
```

**3단계: AI 자율 작업**

```
Dev Agent:
1. Figma 디자인 읽기
2. 컴포넌트 작성
3. 브라우저 오픈
4. 스크린샷 찍기
5. "음... 버튼 위치가 3px 틀렸네"
6. 코드 수정
7. 다시 확인
8. "완료!"

Reviewer Agent:
1. 코드 읽기
2. 디자인과 비교
3. "간격이 조금 좁은데요?"
4. 수정 요청

Dev Agent:
1. 수정
2. 재확인

Reviewer Agent:
"완벽합니다. Approve!"
```

### ⚠️ 주의: 무한 루프 함정

**문제:**

AI가 리뷰 → 수정 → 리뷰 → 수정을 **무한 반복**할 수 있습니다.

**원인:**
- 너무 큰 작업
- 너무 복잡한 요구사항
- 애매한 승인 기준

**해결책:**

1. **작은 단위로 쪼개기**
   ```
   ❌ "전체 대시보드 만들어"
   ✅ "헤더만 만들어"
   ✅ "사이드바만 만들어"
   ```

2. **명확한 승인 기준**
   ```
   ❌ "예쁘게 만들어"
   ✅ "디자인과 정확히 일치하면 승인"
   ```

3. **최대 반복 횟수 설정**
   ```
   "3번 반복해도 안 되면 사람한테 물어봐"
   ```

---

## 💰 비용 절감 꿀팁 총정리

### 1. Chrome DevTools > Playwright

```
같은 작업:
Playwright: 40K 토큰
Chrome DevTools: 10K 토큰

→ 4배 절약!
```

### 2. 선택적 MCP 활성화

```
현재 작업에 필요한 것만 켜기:

프론트 작업:
✅ Figma + Chrome
❌ Postgres

백엔드 작업:
✅ Postgres
❌ Figma
```

### 3. Serena는 필수

```
코드베이스 인덱싱
→ 70% 토큰 절약
→ 더 정확한 코드
```

### 4. 작은 태스크로 쪼개기

```
❌ "쇼핑몰 만들어" (50K 토큰)
✅ "장바구니 버튼만" (5K 토큰)
→ 10배 효율!
```

### 5. Sequential Thinking 활성화

```
한 번에 생각 → 실수 많음
단계별 생각 → 정확함
```

---

## 📋 체크리스트: 당신의 설정은 최적인가?

### 필수 MCP (항상 켜기)

- [ ] Serena (토큰 절약)
- [ ] Sequential Thinking (정확도)
- [ ] Context7 또는 Perplexity (최신 정보)

### 상황별 MCP

**프론트엔드 작업 시:**
- [ ] Figma MCP
- [ ] Chrome DevTools MCP

**백엔드 작업 시:**
- [ ] Postgres/DB MCP
- [ ] Task Master AI

**복잡한 프로젝트:**
- [ ] 서브 에이전트 설정
- [ ] 워크플로우 정의 (.claude/claude.md)

### 비용 최적화

- [ ] /usage로 주기적 확인
- [ ] /context로 MCP 점유율 확인
- [ ] 불필요한 MCP disable
- [ ] Chrome DevTools 우선 사용

### 품질 관리

- [ ] 작은 태스크로 쪼개기
- [ ] 명확한 승인 기준
- [ ] 최대 반복 횟수 제한

---

## 🎓 FAQ: 자주 묻는 질문

### Q1. 어떤 플랜을 써야 하나요?

**가벼운 사용 (주 5시간 미만):**
→ Pro ($20/월)

**본격 사용 (주 10~20시간):**
→ Max ($100/월) 또는 Teams ($200/월)

**팀 단위:**
→ Teams ($200/월) 필수

### Q2. MCP 몇 개까지 켜도 되나요?

**권장: 3~5개**

```
/context로 확인:
MCP Tools: 30% 이하 유지
```

30%를 넘어가면 작업 공간이 부족합니다.

### Q3. Ghostty를 꼭 써야 하나요?

아니요! 아무 터미널이나 괜찮습니다.

**Ghostty 장점:**
- 크로스 플랫폼
- 빠름
- 메모리 효율적

**하지만:**
- iTerm2 (Mac)
- Windows Terminal (Windows)
- 그냥 기본 터미널

다 괜찮습니다!

### Q4. 비개발자도 쓸 수 있나요?

**Claude Code:** 개발 지식 필요
**Claude Desktop:** 누구나 가능!

Claude Desktop도:
- Notion 연동
- GitHub 연동
- 다양한 커넥터

기획자, 디자이너도 충분히 활용 가능합니다.

### Q5. Sonnet vs Opus 어떤 게 좋나요?

**2024년 11월 현재:**

| 모델 | 성능 | 비용 | 추천 |
|------|------|------|------|
| Sonnet 4.5 | ⭐⭐⭐⭐⭐ | $ | ✅ |
| Opus 4.1 | ⭐⭐⭐⭐ | $$$$$ | ❌ |

**결론: Sonnet 4.5 쓰세요!**

---

## 💭 마무리: AI는 도구일 뿐

### 코드 에디터는 사라질까요?

어쩌면 그럴 수도 있습니다.

하지만 **"개발"의 본질은 변하지 않습니다.**

### 개발의 본질

❌ **코드 작성이 아닙니다**
✅ **문제 해결입니다**

```
1. 문제 이해하기
2. 해결책 설계하기
3. 구현하기 (← AI가 도와줌)
4. 검증하기
```

AI는 3번을 빠르게 해줍니다.

하지만 1, 2, 4는 **여전히 사람의 몫**입니다.

### 재미는 어디에?

10년 전:
```
"C로 메모리 직접 관리하는 재미!"
→ 지금은 Python/JavaScript 씀
→ 재미 사라졌나요? 아니요!
```

지금:
```
"손으로 코딩하는 재미!"
→ 미래에는 AI가 도와줌
→ 재미 사라질까요? 아니요!
```

**재미의 본질은 "무언가를 만드는 것"**입니다.

붓으로 그림 그리든, 태블릿으로 그리든, **창작의 즐거움**은 변하지 않습니다.

### 당신의 선택

2025년, 두 종류의 개발자:

**1. AI를 무서워하는 개발자**
```
"AI가 내 자리를 뺏을 거야"
→ AI 안 쓰기
→ 생산성 정체
→ 경쟁력 하락
```

**2. AI를 도구로 쓰는 개발자**
```
"AI로 지루한 일은 빠르게"
→ 더 어려운 문제 도전
→ 더 창의적인 일에 집중
→ 경쟁력 상승
```

**어떤 개발자가 되고 싶으신가요?**

---

## 🔗 더 알아보기

**참고 자료:**
- [Serena MCP GitHub](https://github.com/serena-mcp)
- [Task Master AI](https://github.com/task-master-ai)
- [Anthropic MCP Documentation](https://docs.anthropic.com/mcp)
- [Context7](https://context7.com)
- [Perplexity API](https://perplexity.ai/api)

**추천 플러그인:**
- [BMat Metathings](https://github.com/bmat-metathings)
- [Superpowers](https://github.com/obra/superpowers)

---

## 🚀 당장 시작하기

**Day 1: 기본 설정**
1. Claude Code 설치
2. /usage, /context 명령어 익히기
3. Pro 플랜으로 시작

**Day 2-3: 필수 MCP 설치**
1. Serena MCP
2. Sequential Thinking
3. Context7 또는 Perplexity

**Day 4-7: 실전 적용**
1. 작은 프로젝트로 연습
2. 토큰 사용량 추적
3. 최적화 실험

**Week 2: 고급 기능**
1. 서브 에이전트 설정
2. 워크플로우 정의
3. 팀에 공유

---

**P.S.** 월 $200 날리기 전에 이 글을 찾으셨다면 축하합니다. 저처럼 시행착오를 겪지 않으셔도 됩니다. 😊

**P.P.S.** 이미 $200 날리셨다면... 환영합니다, 동지여. 우리는 같은 길을 걸었습니다. 🤝

**토큰을 아끼고, 생산성은 높이세요!** 🎯