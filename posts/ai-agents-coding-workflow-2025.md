# AI 에이전트로 코딩 시간 절반 날린 후기 (그런데 오히려 생산성은 2배)

**"AI한테 일 맡기면 실력 퇴보하는 거 아닌가요?"**

저도 똑같이 생각했습니다. 2024년 말까지만 해도요.

그런데 현실을 직시해야 했습니다.

옆자리 3년차 개발자는 저보다 기능을 2배 빠르게 배포하고 있었고, 저는 여전히 "ChatGPT는 그냥 구글 검색 대용"이라고 생각하며 코드를 복붙하고 있었으니까요.

**그 순간 깨달았습니다.**

문제는 AI를 쓰느냐 마느냐가 아니라,
**"어떻게 협업하느냐"**였습니다.

이 글은 제가 AI를 "더 똑똑한 스택오버플로우"에서 **"24시간 일하는 4명의 팀원"**으로 바꾼 이야기입니다.

---

## 📊 먼저, 숫자부터 보여드리겠습니다

말로만 "생산성 2배!"라고 하면 안 믿으시죠? 저도 그랬습니다.

그래서 1주일 동안 실제로 시간을 쟀습니다:

| 작업 유형 | 이전 방식 | AI 협업 후 | 절감률 |
|---------|---------|-----------|--------|
| 중간 규모 기능 개발 | 7시간 | 3시간 | **57%** |
| 버그 조사 & 수정 | 3시간 | 1.5시간 | **50%** |
| 테스트 커버리지 증가 | 5시간 | 2시간 | **60%** |
| 로깅/모니터링 개선 | 4시간 | 1.5시간 | **62%** |

**평균 54% 시간 절약.**

하지만 여기서 중요한 건 "시간을 아낀 것"이 아닙니다.

### 진짜 변화는 이거였습니다

**이전:**
- 7시간 중 5시간 = 코드 읽고, 찾고, 복붙하고, 고치기
- 2시간 = 진짜 생각하기

**지금:**
- 3시간 중 0.5시간 = 단순 작업
- 2.5시간 = **설계, 트레이드오프 고민, 리뷰**

시간을 절반 날렸는데 오히려 **생각할 시간이 늘어났습니다.**

---

## 🎭 비유: 오케스트라 지휘자가 되다

이전에는 제가 모든 악기를 혼자 연주했습니다.

- 바이올린(코드 작성)도 제가
- 첼로(테스트)도 제가
- 트럼펫(문서화)도 제가
- 심지어 악보(스펙) 정리도 제가

당연히 피곤했죠.

**지금은 4명의 연주자가 있고, 저는 지휘자입니다.**

각 연주자(AI 에이전트)에게 명확한 역할을 주고,
제가 전체 음악(프로젝트)의 방향을 잡습니다.

이게 바로 **SCCR 워크플로우**입니다.

---

## 🚀 SCCR: 4명의 팀원을 소개합니다

### 1. **Spec Agent** - 까다로운 PM

"이 기능 추가해주세요"라고 말하면
"구체적으로 뭘 원하시는데요?"라고 되묻는 역할입니다.

**실제 대화 예시:**

```
나: "결제 재시도 로직 추가하고 싶어"

Spec Agent:
- 영구 실패와 임시 실패를 어떻게 구분하나요?
- 최대 재시도 횟수는?
- 각 시도마다 사용자에게 뭘 보여주나요?
- 재무팀이 나중에 이걸 어떻게 추적하나요?
```

처음엔 짜증났습니다. "그냥 만들면 되지 뭘 그렇게 물어봐?"

**하지만 이 질문들 덕분에 코드 쓰기 전에 설계가 끝납니다.**

코딩하면서 "어? 이 케이스는?"하는 일이 거의 사라졌어요.

---

### 2. **Context Agent** - 코드베이스 가이드

새 회사 첫날, 선배가 "여기 코드 좀 만져봐"라고 던져주면
어디서부터 봐야 할지 모르죠?

Context Agent가 그 선배입니다.

**실제 사용 예시:**

```
나: "결제 재시도 관련된 코드 찾아줘"

Context Agent:
📁 이 파일들 확인하세요:
- payment-service.ts (메인 로직)
- retry-handler.ts (기존 재시도 로직 있음 - 조심!)
- notification.ts (사용자 알림)

⚠️ 주의:
- retry-handler.ts:42에 "이 순서 바꾸지 마세요" 주석 있음
- 2년 전 핫픽스 코드가 아직 있음 (line 156)
```

이제 3시간 걸릴 코드 읽기가 10분이면 끝납니다.

---

### 3. **Code Agent** - 열정적인 주니어

"이 기능 만들어줘"라고 하면
"네! 이렇게 하면 어떨까요?"하고 초안을 가져오는 역할입니다.

**중요: 저는 절대 그대로 쓰지 않습니다.**

마치 주니어가 PR 올리면 시니어가 리뷰하듯이,
저는 항상 모든 줄을 읽고 고칩니다.

**실제 프롬프트 예시:**

```
당신은 조심스러운 시니어 엔지니어입니다.
이 함수만 수정하세요. 새 의존성 추가 금지.

목표: 지수 백오프 재시도 추가

현재 코드:
async function processPayment(order) {
  // ... 기존 코드
}

1. 수정된 코드 보여주기
2. 변경 사항 설명
3. 추가해야 할 테스트 제안
```

초안이 10초면 나옵니다.
제가 리뷰하고 고치는 데 10분.

이전엔 처음부터 짜는 데 1시간 걸렸습니다.

---

### 4. **Review Agent** - 꼼꼼한 리뷰어

코드 다 짰으면 끝인가요? 아니죠.

Review Agent는 제가 놓친 걸 찾아줍니다.

**실제 리뷰 예시:**

```
나: "이 코드 리뷰해줘"

Review Agent:
✅ 좋은 점:
- 에러 핸들링 잘 되어 있음
- 로그도 충분함

⚠️ 걱정되는 부분:
1. PG사가 이상한 응답 코드 보내면? (예: 999)
2. maxRetries가 0이면 무한루프 가능
3. 로그만으로 디버깅 힘들 것 같음 (트랜잭션 ID 추가 권장)

💡 추가 테스트 제안:
- PG 타임아웃 시나리오
- 네트워크 단절 중 재시도
```

리뷰어가 24시간 대기하고 있는 느낌입니다.

---

## 🏗️ 실전 사례: 배달 앱 결제 재시도 시스템

### 문제 상황

3년 묵은 레거시 결제 시스템에 재시도 로직을 추가해야 했습니다.

**이전 방식이었다면:**
1. 하루 종일 코드 읽기
2. 어디를 고쳐야 할지 찾기
3. 조심조심 코드 추가
4. 테스트 돌려보고 에러나면 다시 찾기
5. 리뷰 받고 다시 수정

**총 소요 시간: 2일**

### AI 협업 방식

#### Step 1: Spec Agent와 요구사항 정리 (20분)

```
나: "PG 결제 실패할 때 3번까지 재시도하게 만들고 싶어"

Spec Agent:
Q1. 어떤 실패를 재시도하나요?
   - 타임아웃: 재시도 O
   - 잔액부족: 재시도 X
   - 카드정지: 재시도 X

Q2. 재시도 간격은?
   - 1차: 2초 후
   - 2차: 4초 후
   - 3차: 8초 후 (지수 백오프)

Q3. 사용자에게 뭘 보여주나요?
   - 재시도 중: "결제 처리 중입니다..."
   - 성공: "결제 완료!"
   - 최종 실패: "결제 실패. 카드를 확인해주세요"
```

20분 대화 후 요구사항이 명확해졌습니다.

#### Step 2: Context Agent로 코드 탐색 (10분)

```
Context Agent 결과:

📁 주요 파일:
- payment.service.ts:145 - 실제 PG 호출
- order.repository.ts:89 - 주문 상태 업데이트
- notification.service.ts:34 - 사용자 알림

⚠️ 위험 요소:
- payment.service.ts:156 - 2022년 핫픽스 (순서 바꾸면 안 됨)
- 로깅이 부족함 (디버깅 어려울 수 있음)
```

#### Step 3: Code Agent로 초안 생성 (5분)

```typescript
// Code Agent가 제안한 코드

async function processPaymentWithRetry(order: Order) {
  const maxRetries = 3;
  const baseDelay = 2000; // 2초

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const result = await pgClient.charge(order);

      logger.info('Payment success', {
        orderId: order.id,
        attempt
      });

      return result;

    } catch (error) {
      // 재시도 불가능한 에러
      if (isPermanentError(error)) {
        throw error;
      }

      // 마지막 시도였으면 에러
      if (attempt === maxRetries) {
        throw error;
      }

      // 지수 백오프
      const delay = baseDelay * Math.pow(2, attempt);
      await sleep(delay);

      logger.warn('Payment retry', {
        orderId: order.id,
        attempt: attempt + 1,
        nextDelay: delay
      });
    }
  }
}
```

#### Step 4: 제가 리뷰하고 수정 (15분)

Code Agent 코드는 80% 정도만 맞았습니다.

제가 추가/수정한 것:
- `transactionId` 추가 (트랜잭션 추적용)
- `isPermanentError()` 로직 구체화
- 에러별 사용자 메시지 다르게
- 모니터링을 위한 메트릭 추가

#### Step 5: Review Agent로 최종 점검 (10분)

```
Review Agent 피드백:

✅ 잘한 점:
- 로깅 잘 되어 있음
- 에러 핸들링 견고함

🤔 추가 고려사항:
1. PG사 점검 중이면 재시도 의미 없음 → 별도 처리 필요
2. maxRetries 설정값으로 빼는 게 나음 (하드코딩 X)
3. 동시 재시도로 인한 중복 결제 가능성 체크

📝 테스트 케이스:
- 타임아웃 3번 후 성공
- 2번째 시도에서 성공
- 영구 에러는 바로 실패
- 네트워크 단절 시나리오
```

#### 결과

**총 소요 시간: 4시간**
(이전: 2일 = 16시간)

**75% 시간 절약!**

더 중요한 건, 코드 품질이 이전보다 **더 좋아졌습니다.**

왜냐하면:
- 설계가 먼저 끝났고
- 엣지 케이스를 미리 고려했고
- 꼼꼼한 리뷰를 받았기 때문입니다

---

## 💻 실제 구현: 복잡하지 않습니다

"4개 에이전트면 시스템이 복잡하겠네요?"

아닙니다. 핵심은 **역할 분리**입니다.

### 전체 구조

```
        개발자 (나)
           ↓
   ┌──────────────┐
   │ Orchestrator │ ← 간단한 스크립트
   └──────────────┘
     │  │  │  │
     ↓  ↓  ↓  ↓
   ┌──┐┌──┐┌──┐┌──┐
   │S ││C ││C ││R │ ← 각각 역할만 다름
   │P ││O ││O ││E │
   │E ││N ││D ││V │
   │C ││T ││E ││I │
   └──┘└──┘└──┘└──┘
```

### 코드로 보면 더 간단합니다

```typescript
type AgentRole = 'spec' | 'context' | 'code' | 'review';

interface AgentTask {
  role: AgentRole;
  goal: string;
  context: string;
}

async function runAgent(task: AgentTask): Promise<string> {
  // 1. 역할에 맞는 시스템 메시지 설정
  const systemMessage = getSystemMessage(task.role);

  // 2. LLM에게 요청
  const prompt = `${systemMessage}\n\n목표:\n${task.goal}\n\n컨텍스트:\n${task.context}`;

  const result = await llm.complete({ prompt });

  return result.text;
}

function getSystemMessage(role: AgentRole): string {
  const messages = {
    spec: '당신은 까다로운 PM입니다. 애매한 요구사항을 구체화하세요.',
    context: '당신은 코드베이스 가이드입니다. 관련 파일과 위험 요소를 찾으세요.',
    code: '당신은 조심스러운 시니어입니다. 안전한 코드를 작성하세요.',
    review: '당신은 꼼꼼한 리뷰어입니다. 놓친 부분을 찾으세요.'
  };

  return messages[role];
}
```

**핵심은 "복잡한 시스템"이 아니라 "명확한 역할"입니다.**

---

## 🚨 어디까지 AI를 믿어야 할까?

### ✅ AI에게 맡기는 것

1. **반복적인 코드 작성**
   - CRUD API 초안
   - 테스트 케이스 스켈레톤
   - 타입 정의

2. **정보 찾기**
   - 관련 코드 위치
   - 에러 원인 추정
   - 라이브러리 사용법

3. **코드 리뷰 1차**
   - 명백한 버그
   - 놓친 엣지 케이스
   - 네이밍 제안

### ❌ AI에게 절대 맡기지 않는 것

1. **최종 결정**
   - 아키텍처 설계
   - 기술 스택 선택
   - 트레이드오프 판단

2. **보안 & 컴플라이언스**
   - 인증/인가 로직
   - 암호화 구현
   - 개인정보 처리

3. **배포 & 운영**
   - 프로덕션 배포
   - DB 마이그레이션
   - 롤백 결정

4. **사람과의 소통**
   - 팀원과의 신뢰 구축
   - 이해관계자 설득
   - 멘토링

### 비유: 조종사와 자동조종장치

비행기에는 자동조종장치가 있지만,
**조종사는 항상 조종석에 앉아 있습니다.**

- 순항 중: 자동조종 (AI 활용)
- 이착륙, 비상 상황: 수동 조종 (직접 판단)

AI도 마찬가지입니다.

**저는 조종사이고, AI는 자동조종장치입니다.**

---

## 📈 1주일 실험: 실제 데이터

"그래서 정말 생산성 올라요?"

제 1주일 실험 결과입니다.

### 작업 1: 새 API 엔드포인트 추가

**작업 내용:** 사용자 알림 설정 API

이전 방식:
```
- 요구사항 이해: 30분
- 코드베이스 탐색: 1시간
- 구현: 2시간
- 테스트 작성: 1.5시간
- 리뷰 & 수정: 1시간
총: 6시간
```

AI 협업:
```
- Spec Agent로 요구사항 정리: 15분
- Context Agent로 관련 코드 찾기: 10분
- Code Agent 초안 + 내가 수정: 45분
- 테스트 (AI가 케이스 제안): 40분
- Review Agent 점검: 10분
총: 2시간
```

**시간 절약: 67%**

### 작업 2: 레거시 버그 수정

**작업 내용:** 간헐적으로 발생하는 타임아웃 이슈

이전 방식:
```
- 버그 재현: 1시간
- 원인 찾기: 2시간
- 수정: 30분
- 테스트: 1시간
총: 4.5시간
```

AI 협업:
```
- Context Agent로 의심 구간 찾기: 20분
- 직접 디버깅: 1시간
- Code Agent 수정 제안 + 검토: 20분
- Review Agent로 사이드 이펙트 체크: 15분
총: 2시간
```

**시간 절약: 56%**

### 작업 3: 테스트 커버리지 증가

**작업 내용:** payment.service.ts 커버리지 40% → 80%

이전 방식:
```
- 어떤 테스트가 필요한지 파악: 1시간
- 테스트 작성: 3시간
- 엣지 케이스 추가: 1시간
총: 5시간
```

AI 협업:
```
- Code Agent에게 "이 파일 테스트 제안해줘": 5분
- 제안된 30개 케이스 검토: 20분
- 핵심 20개 케이스 구현 (AI 초안 활용): 1.5시간
총: 2시간
```

**시간 절약: 60%**

### 📊 1주일 누적

| 항목 | 이전 | AI 협업 | 절약 |
|------|------|---------|------|
| 기능 개발 | 18시간 | 8시간 | 56% |
| 버그 수정 | 9시간 | 4시간 | 56% |
| 테스트 작성 | 10시간 | 4시간 | 60% |
| **합계** | **37시간** | **16시간** | **57%** |

**하지만 진짜 변화는 여기:**

남은 24시간(40시간 - 16시간)을 뭐했을까요?

- 시스템 설계 문서 작성
- 주니어 개발자 멘토링
- 기술 부채 정리 계획 수립
- 새로운 기술 스터디

**단순히 "빨라진 게" 아니라 "진짜 중요한 일에 집중"하게 됐습니다.**

---

## 🎯 당장 시작하는 법 (3단계)

"오늘부터 어떻게 시작하죠?"

### Step 1: 가장 짜증나는 일 하나만 선택 (5분)

다음 중 골라보세요:

- [ ] 레거시 코드 읽기
- [ ] 반복적인 CRUD 작성
- [ ] 테스트 케이스 작성
- [ ] 에러 로그 분석

**하나만 고르세요!** 다 하려고 하면 실패합니다.

### Step 2: 그 일을 도와줄 에이전트 하나만 만들기 (10분)

예를 들어 "레거시 코드 읽기"를 선택했다면:

```typescript
// context-agent.ts

async function explainCode(filePath: string) {
  const code = await readFile(filePath);

  const prompt = `
당신은 친절한 시니어 개발자입니다.
이 코드를 주니어에게 설명해주세요.

1. 이 코드가 하는 일 (3줄 요약)
2. 주의해야 할 부분
3. 수정할 때 영향받는 다른 코드

코드:
${code}
  `;

  const result = await llm.complete({ prompt });
  console.log(result.text);
}
```

### Step 3: 1주일 매일 써보기

- 월: 새로운 파일 볼 때 사용
- 화: 버그 수정할 때 사용
- 수: 리팩토링할 때 사용
- ...

**1주일 후:**
- 시간이 절약되었나?
- 어떤 부분이 도움됐나?
- 어떤 부분이 짜증났나?

도움이 됐다면, 두 번째 에이전트 추가하세요.

---

## 💡 실전 프롬프트 템플릿 모음

### Spec Agent 프롬프트

```
당신은 까다로운 PM입니다.
아래 기능 설명을 읽고 부족한 부분을 질문하세요.

목표: 테스트 가능한 명확한 스펙으로 만들기

규칙:
1. 애매한 표현 지적
2. 엣지 케이스 물어보기
3. 측정 가능한 기준 제시

기능 설명:
[여기에 여러분의 아이디어 입력]

질문 형식:
- 명확히 해야 할 부분: ...
- 고려해야 할 케이스: ...
- 성공 기준: ...
```

### Context Agent 프롬프트

```
당신은 코드베이스 가이드입니다.

목표: [변경하려는 기능]

다음 파일들에서:
[관련 파일 목록]

아래 내용을 찾아주세요:
1. 어디서 이 기능이 구현되어 있나?
2. 수정하면 영향받는 부분은?
3. 주의해야 할 주석이나 TODO가 있나?

형식:
📁 주요 파일: ...
⚠️ 위험 요소: ...
💡 참고사항: ...
```

### Code Agent 프롬프트

```
당신은 조심스러운 시니어 엔지니어입니다.

제약사항:
- 제공된 함수만 수정
- 새 의존성 추가 금지
- 기존 API 변경 금지

목표:
[구체적인 변경 사항]

현재 코드:
```typescript
[여기에 코드 붙여넣기]
```

응답 형식:
1. 수정된 코드
2. 변경 사항 설명 (3줄)
3. 추가할 테스트 케이스 (5개)
```

### Review Agent 프롬프트

```
당신은 꼼꼼한 코드 리뷰어입니다.

아래 코드를 리뷰해주세요:

```typescript
[수정한 코드]
```

리뷰 기준:
1. 에러 핸들링 충분한가?
2. 엣지 케이스 놓친 건 없나?
3. 성능 이슈 가능성은?
4. 테스트하기 어려운 부분은?

응답 형식:
✅ 좋은 점: ...
⚠️ 걱정되는 부분: ...
💡 개선 제안: ...
📝 추가 테스트 필요: ...
```

---

## 🤔 자주 묻는 질문 (FAQ)

### Q1. "AI 의존하면 실력 퇴보하지 않나요?"

**A:** 오히려 반대입니다.

**비유:** 계산기 쓴다고 수학 실력 떨어지나요?

- 계산기 쓰면 → 복잡한 문제 풀 시간 생김
- AI 쓰면 → 설계와 트레이드오프 고민할 시간 생김

제 경험:
- **이전:** 코드 작성에 80% 시간 → 단순 기능 개발자
- **지금:** 설계에 60% 시간 → 시스템 설계자

**더 높은 수준의 문제를 다루게 됩니다.**

### Q2. "보안 이슈 없나요?"

**A:** 회사 코드를 외부 AI에 그대로 넘기면 안 됩니다.

**안전하게 쓰는 법:**
1. 민감한 정보 제거 후 사용
2. 사내 LLM 서버 구축 (Claude, GPT self-hosted)
3. 로컬 LLM 사용 (Llama, Mistral 등)

제 경우:
- 로직 구조만 AI에게 보여주기
- API 키, DB 정보 등은 제거
- 회사 정책에 따라 사내 LLM 사용

### Q3. "비용 많이 안 드나요?"

**A:** API 비용 vs 절약한 시간 비교하면 됩니다.

제 1개월 실제 비용:
- Claude API: $45
- 절약한 시간: 80시간
- 제 시급 환산: $50/시간
- ROI: **($50 × 80시간) / $45 = 89배**

**커피값으로 두 배 일합니다.**

### Q4. "프롬프트 작성이 어렵지 않나요?"

**A:** 처음엔 어색하지만 3일이면 익숙해집니다.

**팁:**
1. 역할 먼저 정하기 ("당신은 ~입니다")
2. 제약사항 명확히 ("~하지 마세요")
3. 출력 형식 지정 ("1. ... 2. ... 형식으로")

위 템플릿만 복붙해서 써도 80%는 해결됩니다.

### Q5. "팀 전체가 써야 효과 있나요?"

**A:** 아니요, 혼자 써도 됩니다.

실제로:
- 저만 AI 협업 사용
- 팀원들은 기존 방식 유지
- 3주 후 팀원들이 "어떻게 그렇게 빨리 끝내요?" 물어봄
- 지금은 팀 전체가 사용

**혼자 시작해서 보여주는 게 낫습니다.**

### Q6. "실수하면 어떡하죠?"

**A:** AI도 틀립니다. 자주 틀립니다.

**그래서:**
- 모든 코드를 제가 직접 리뷰
- 테스트는 필수
- 중요한 부분은 사람이 다시 확인

**AI는 "초안 작성자"이지 "최종 결정자"가 아닙니다.**

---

## 🎬 마지막: 2025년의 두 종류의 개발자

지금 이 순간, 두 명의 개발자가 있습니다.

**개발자 A:**
- 경력: 5년
- 실력: 뛰어남
- AI: "그냥 검색 대용"

**개발자 B:**
- 경력: 3년
- 실력: 비슷함
- AI: "4명의 팀원"

이력서에는 같아 보입니다.

**하지만 현실에서:**

개발자 A:
- 기능 하나에 3일
- 항상 바쁨
- "시간이 없어서..."

개발자 B:
- 같은 기능 1.5일
- 여유 있음
- "이번 주 시스템 설계 문서 작성했어요"

**1년 후:**

개발자 A:
- 여전히 기능 개발
- "왜 승진이 안 되지?"

개발자 B:
- 아키텍처 설계
- 팀 리드

---

## 💭 당신의 선택

이 글을 다 읽으셨다면 두 가지 선택지가 있습니다.

**선택 1: "나중에 해봐야지"**
- 내일: 똑같은 방식으로 일함
- 다음 주: 여전히 바쁨
- 1년 후: "그때 했어야 하는데..."

**선택 2: "오늘 30분만 투자"**
- 지금: 가장 짜증나는 일 하나 선택
- 오늘: 그걸 도와줄 프롬프트 하나 만들기
- 내일: 써보기
- 1주일 후: 시간 절약 체감
- 1년 후: 완전히 다른 레벨의 개발자

---

## 🚀 실천 계획 (지금 바로)

### 오늘 (10분)

1. [ ] 가장 짜증나는 작업 하나 고르기
2. [ ] 위 템플릿 중 하나 복사하기
3. [ ] ChatGPT/Claude에 붙여넣고 써보기

### 이번 주 (매일 10분)

1. [ ] 월: 같은 작업에 다시 사용
2. [ ] 화: 프롬프트 조금 수정해보기
3. [ ] 수: 다른 작업에도 적용
4. [ ] 목: 시간 절약 측정
5. [ ] 금: 두 번째 에이전트 역할 추가

### 다음 주

- 팀원 한 명에게 보여주기
- 피드백 받고 개선하기
- SCCR 전체 워크플로우 구축

---

## 📚 참고 자료

### AI 협업 도구

- [Claude](https://claude.ai) - 긴 컨텍스트, 코드 이해 능력 탁월
- [ChatGPT](https://chat.openai.com) - 범용적, 빠른 응답
- [GitHub Copilot](https://github.com/features/copilot) - IDE 통합

### 프롬프트 엔지니어링

- [Anthropic Prompt Library](https://docs.anthropic.com/claude/prompt-library)
- [OpenAI Best Practices](https://platform.openai.com/docs/guides/prompt-engineering)

### 로컬 LLM (보안 중요할 때)

- [Ollama](https://ollama.ai) - 로컬 LLM 쉽게 설치
- [LM Studio](https://lmstudio.ai) - GUI로 로컬 LLM 관리

---

## ✍️ 마무리

3개월 전의 저는 AI를 "더 똑똑한 구글"로 생각했습니다.

지금의 저는 AI를 "24시간 대기하는 4명의 팀원"으로 일합니다.

**바뀐 건 AI가 아닙니다.**
**바뀐 건 제가 일하는 방식입니다.**

이 글을 읽는 지금,
옆자리 개발자는 이미 AI와 협업하고 있을지도 모릅니다.

**당신은 어떤 개발자가 되고 싶으신가요?**

---

**P.S.** 혹시 이 글이 도움됐다면, 여러분의 경험도 댓글로 공유해주세요.
특히 "이렇게 써봤는데 이런 점이 좋았어요/아쉬웠어요" 같은 실전 후기를 듣고 싶습니다! 🙏

**P.P.S.** 다음 글 예고: "SCCR 워크플로우를 TypeScript로 구현하기 (실전 코드 공개)" - 관심 있으시면 구독해주세요! 🚀
